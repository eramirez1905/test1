# name: Github Actions test

# on:
#   pull_request:
#   push:
#     branches:
#       - airflow

# jobs:
#   test:
#     name: Running Units Tests
#     runs-on: ubuntu-latest

name: Testing Airflow workflow
on:
  push:
    branches:
      - airflow
# jobs:
#   checkout:
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout
#         uses: actions/checkout@master
#   python_lint:
#     needs: checkout
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@master
#       - uses: actions/setup-python@v2
#         with:
#           python-version: '3.8'
#       - name: Test
#         uses: onichandame/python-test-action@master
#         with:
#           deps_list: 'requirements'
#   styles:
#     needs: python_lint
#     runs-on: ubuntu-18.04
#     name: Linting
#     steps:
#       - uses: actions/checkout@master
#       - uses: actions/setup-python@v1
#       - uses: whynothugo/python-linting@master
  
# name: Testing Airflow workflow
# on:
#   push:
#     branches:
#       - airflow

jobs:

  cancel-workflow-runs:
    timeout-minutes: 10
    name: "Cancel workflow runs"
    runs-on: ${{ github.repository == 'apache/airflow' && 'self-hosted' || 'ubuntu-20.04' }}
    outputs:
      sourceHeadRepo: ${{ steps.source-run-info.outputs.sourceHeadRepo }}
      sourceHeadBranch: ${{ steps.source-run-info.outputs.sourceHeadBranch }}
      sourceHeadSha: ${{ steps.source-run-info.outputs.sourceHeadSha }}
      mergeCommitSha: ${{ steps.source-run-info.outputs.mergeCommitSha }}
      targetCommitSha: ${{ steps.source-run-info.outputs.targetCommitSha }}
      pullRequestNumber: ${{ steps.source-run-info.outputs.pullRequestNumber }}
      pullRequestLabels: ${{ steps.source-run-info.outputs.pullRequestLabels }}
      targetBranch: ${{ steps.source-run-info.outputs.targetBranch }}
      sourceEvent: ${{ steps.source-run-info.outputs.sourceEvent }}
      cacheDirective: ${{ steps.cache-directive.outputs.docker-cache }}
      buildImages: ${{ steps.build-images.outputs.buildImages }}
      runsOn: ${{ github.repository == 'apache/airflow' && '["self-hosted"]' || '["ubuntu-20.04"]' }}
    steps:
      - name: "Checkout ${{ github.ref }} ( ${{ github.sha }} )"
        uses: actions/checkout@v2
        with:
          persist-credentials: false
          submodules: recursive
      - name: "Get information about the original trigger of the run"
        uses: ./.github/actions/get-workflow-origin
        id: source-run-info
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          sourceRunId: ${{ github.event.workflow_run.id }}
      - name: "Cancel duplicated 'CI Build' runs"
        uses: ./.github/actions/cancel-workflow-runs
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          cancelMode: allDuplicates
          sourceRunId: ${{ github.event.workflow_run.id }}
      - name: "Output BUILD_IMAGES"
        id: build-images
        run: |
          # Workaround - jobs cannot access env variable in "ifs"
          # https://github.community/t/how-to-set-and-access-a-workflow-variable/17335/16
          echo "::set-output name=buildImages::${BUILD_IMAGES}"
      - name: "Cancel duplicated 'Build Image' runs"
        # We find duplicates of our own "Build Image" runs - due to a missing feature
        # in GitHub Actions, we have to use Job names to match Event/Repo/Branch matching
        # trick ¯\_(ツ)_/¯. We name the build-info job appropriately
        # and then we try to find and cancel all the jobs with the same Event + Repo + Branch as the
        # current Event/Repo/Branch combination.
        uses: ./.github/actions/cancel-workflow-runs
        with:
          cancelMode: namedJobs
          token: ${{ secrets.GITHUB_TOKEN }}
          notifyPRCancel: true
          jobNameRegexps: >
            [".*Event: ${{ steps.source-run-info.outputs.sourceEvent }}
            Repo: ${{ steps.source-run-info.outputs.sourceHeadRepo }}
            Branch: ${{ steps.source-run-info.outputs.sourceHeadBranch }}.*"]
        if: env.BUILD_IMAGES == 'true'
      - name: "Cancel all 'CI Build' runs where some jobs failed"
        # We find any of the "CI Build" workflow runs, where any of the important jobs
        # failed. The important jobs are selected by the regexp array below.
        # We also produce list of canceled "CI Build' runs as output, so that we
        # can cancel all the matching "Build Images" workflow runs in the two following steps.
        # Yeah. Adding to the complexity ¯\_(ツ)_/¯.
        uses: ./.github/actions/cancel-workflow-runs
        id: cancel-failed
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          cancelMode: failedJobs
          sourceRunId: ${{ github.event.workflow_run.id }}
          notifyPRCancel: true
          jobNameRegexps: >
            ["^Pylint$", "^Static checks", "^Build docs$", "^Spell check docs$",
             "^Provider packages", "^Checks: Helm tests$", "^Test OpenAPI*"]
      - name: "Extract canceled failed runs"
        # We use this step to build regexp that will be used to match the Source Run id in
        # the build-info job below. If we cancelled some "CI Build" runs in the "cancel-failed' step
        # above - we want to cancel also the corresponding "Build Images" runs. Again we have
        # to match the jobs using job name rather than use proper API because that feature
        # is currently missing in GitHub Actions ¯\_(ツ)_/¯.
        id: extract-cancelled-failed-runs
        if: steps.cancel-failed.outputs.cancelledRuns != '[]'
        run: |
            REGEXP="Source Run id: "
            SEPARATOR=""
            for run_id in $(echo "${{ steps.cancel-failed.outputs.cancelledRuns }}" | jq '.[]')
            do
                REGEXP="${REGEXP}${SEPARATOR}(${run_id})"
                SEPARATOR="|"
            done
            echo "::set-output name=matching-regexp::[\"${REGEXP}\"]"
      - name: "Cancel triggered 'Build Images' runs for the cancelled failed runs"
        # In case we do have some cancelled jobs in the "cancel-failed" step above
        # We take the extracted regexp array prepared in the previous step and we use
        # it to cancel any jobs that have matching names containing Source Run Id:
        # followed by one of the run ids. Yes I know it's super complex ¯\_(ツ)_/¯.
        if: env.BUILD_IMAGES == 'true' && steps.cancel-failed.outputs.cancelledRuns != '[]'
        uses: ./.github/actions/cancel-workflow-runs
        with:
          cancelMode: namedJobs
          token: ${{ secrets.GITHUB_TOKEN }}
          notifyPRCancel: true
          jobNameRegexps: ${{ steps.extract-cancelled-failed-runs.outputs.matching-regexp }}
      - name: "Cancel duplicated 'CodeQL' runs"
        uses: ./.github/actions/cancel-workflow-runs
        id: cancel
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          cancelMode: allDuplicates
          workflowFileName: 'codeql-analysis.yml'
      - name: "Set Docker Cache Directive"
        id: cache-directive
        run: |
          if [[ ${{ steps.source-run-info.outputs.sourceEvent }} == 'schedule' ]]; then
              echo "::set-output name=docker-cache::disabled"
          else
              echo "::set-output name=docker-cache::pulled"
          fi
      - name: "Cancel all duplicated 'Build Image' runs"
        # We find duplicates of all "Build Image" runs - due to a missing feature
        # in GitHub Actions, we have to use Job names to match Event/Repo/Branch matching
        # trick ¯\_(ツ)_/¯. We name the build-info job appropriately and then we try to match
        # all the jobs with the same Event + Repo + Branch match and cancel all the duplicates for those
        # This might cancel own run, so this is the last step in the job
        uses: ./.github/actions/cancel-workflow-runs
        with:
          cancelMode: allDuplicatedNamedJobs
          token: ${{ secrets.GITHUB_TOKEN }}
          notifyPRCancel: true
          selfPreservation: false
          jobNameRegexps: '["Event: \\S* Repo: \\S* Branch: \\S* "]'

  build-info:
    # The name is such long because we are using it to cancel duplicated 'Build Images' runs
    # by matching Event/Repo/Branch. This is a workaround for a missing feature of GitHub
    # Actions to link the source workflow run and the triggered workflow_run one.
    # We are also cancelling SourceRunId in case we determine that we should cancel the source
    # Run because of some failing jobs in the source run. Again ¯\_(ツ)_/¯.
    name: >
      Event: ${{ needs.cancel-workflow-runs.outputs.sourceEvent }}
      Repo: ${{ needs.cancel-workflow-runs.outputs.sourceHeadRepo }}
      Branch: ${{ needs.cancel-workflow-runs.outputs.sourceHeadBranch }}
      Run id: ${{ github.run_id }}
      Source Run id: ${{ github.event.workflow_run.id }}
      Sha: ${{ github.sha }}
      Source Sha: ${{ needs.cancel-workflow-runs.outputs.sourceHeadSha }}
      Merge commit Sha: ${{ needs.cancel-workflow-runs.outputs.mergeCommitSha }}
      Target commit Sha: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
    runs-on: ${{ fromJson(needs.cancel-workflow-runs.outputs.runsOn) }}
    needs: [cancel-workflow-runs]
    env:
      GITHUB_CONTEXT: ${{ toJson(github) }}
    outputs:
      pythonVersions: ${{ steps.selective-checks.python-versions }}
      upgradeToNewerDependencies: ${{ steps.selective-checks.outputs.upgrade-to-newer-dependencies }}
      allPythonVersions: ${{ steps.selective-checks.outputs.all-python-versions }}
      defaultPythonVersion: ${{ steps.selective-checks.outputs.default-python-version }}
      run-tests: ${{ steps.selective-checks.outputs.run-tests }}
      run-kubernetes-tests: ${{ steps.selective-checks.outputs.run-kubernetes-tests }}
      image-build: ${{ steps.selective-checks.outputs.image-build }}
    if: >
      needs.cancel-workflow-runs.outputs.buildImages == 'true'
    steps:
      - name: "Checkout ${{ github.ref }} ( ${{ github.sha }} )"
        uses: actions/checkout@v2
        with:
          persist-credentials: false
          submodules: recursive
      - name: >
          Event: ${{ needs.cancel-workflow-runs.outputs.sourceEvent }}
          Repo: ${{ needs.cancel-workflow-runs.outputs.sourceHeadRepo }}
          Branch: ${{ needs.cancel-workflow-runs.outputs.sourceHeadBranch }}
          Run id: ${{ github.run_id }}
          Source Run id: ${{ github.event.workflow_run.id }}
          Sha: ${{ github.sha }}
          Source Sha: ${{ needs.cancel-workflow-runs.outputs.sourceHeadSha }}
          Merge commit Sha: ${{ needs.cancel-workflow-runs.outputs.mergeCommitSha }}
          Target commit Sha: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
        run: printenv
      - name: >
          Fetch incoming commit ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }} with its parent
        uses: actions/checkout@v2
        with:
          ref: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
          fetch-depth: 2
          persist-credentials: false
          submodules: recursive
        if: needs.cancel-workflow-runs.outputs.sourceEvent  == 'pull_request'
      # checkout the master version again, to use the right script in master workflow
      - name: "Checkout ${{ github.ref }} ( ${{ github.sha }} )"
        uses: actions/checkout@v2
        with:
          persist-credentials: false
          submodules: recursive
      - name: Selective checks
        id: selective-checks
        env:
          EVENT_NAME: ${{ needs.cancel-workflow-runs.outputs.sourceEvent }}
          TARGET_COMMIT_SHA: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
          PR_LABELS: ${{ needs.cancel-workflow-runs.outputs.pullRequestLabels }}
        run: |
          if [[ ${EVENT_NAME} == "pull_request" ]]; then
            # Run selective checks
            ./scripts/ci/selective_ci_checks.sh "${TARGET_COMMIT_SHA}"
          else
            # Run all checks
            ./scripts/ci/selective_ci_checks.sh
          fi
  build-ci-images:
    timeout-minutes: 80
    name: "Build CI images ${{matrix.python-version}}"
    runs-on: ${{ fromJson(needs.cancel-workflow-runs.outputs.runsOn) }}
    needs: [build-info, cancel-workflow-runs]
    strategy:
      matrix:
        # We need to attempt to build all possible versions here because workflow_run
        # event is run from master for both master and v1-10-tests
        python-version: ${{ fromJson(needs.build-info.outputs.allPythonVersions) }}
      fail-fast: true
    if: >
      needs.build-info.outputs.image-build == 'true' &&
      needs.cancel-workflow-runs.outputs.buildImages == 'true'
    env:
      RUNS_ON: ${{ fromJson(needs.cancel-workflow-runs.outputs.runsOn)[0] }}
      BACKEND: postgres
      PYTHON_MAJOR_MINOR_VERSION: ${{ matrix.python-version }}
      GITHUB_REGISTRY_PUSH_IMAGE_TAG: ${{ github.event.workflow_run.id }}
      UPGRADE_TO_NEWER_DEPENDENCIES: ${{ needs.build-info.outputs.upgradeToNewerDependencies }}
      CONTINUE_ON_PIP_CHECK_FAILURE: "true"
      DOCKER_CACHE: ${{ needs.cancel-workflow-runs.outputs.cacheDirective }}
      FORCE_PULL_BASE_PYTHON_IMAGE: >
        ${{ needs.cancel-workflow-runs.sourceEvent == 'schedule' && 'true' || 'false' }}
    steps:
      - name: >
          Checkout [${{ needs.cancel-workflow-runs.outputs.sourceEvent }}]
          Event: ${{ needs.cancel-workflow-runs.outputs.sourceEvent }}
          Repo: ${{ needs.cancel-workflow-runs.outputs.sourceHeadRepo }}
          Branch: ${{ needs.cancel-workflow-runs.outputs.sourceHeadBranch }}
          Run id: ${{ github.run_id }}
          Source Run id: ${{ github.event.workflow_run.id }}
          Sha: ${{ github.sha }}
          Source Sha: ${{ needs.cancel-workflow-runs.outputs.sourceHeadSha }}
          Merge commit Sha: ${{ needs.cancel-workflow-runs.outputs.mergeCommitSha }}
          Target commit Sha: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
        uses: actions/checkout@v2
        with:
          ref: ${{ needs.cancel-workflow-runs.outputs.targetCommitSha }}
          persist-credentials: false
          submodules: recursive
      - name: "Retrieve DEFAULTS from the _initialization.sh"
        # We cannot "source" the script here because that would be a security problem (we cannot run
        # any code that comes from the sources coming from the PR. Therefore we extract the
        # DEFAULT_BRANCH and DEFAULT_CONSTRAINTS_BRANCH via custom grep/awk/sed commands
        # Also 2.7 and 3.5 versions are not allowed to proceed on master
        id: defaults
        run: |
          DEFAULT_BRANCH=$(grep "export DEFAULT_BRANCH" scripts/ci/libraries/_initialization.sh | \
            awk 'BEGIN{FS="="} {print $3}' | sed s'/["}]//g')
          echo "DEFAULT_BRANCH=${DEFAULT_BRANCH}" >> $GITHUB_ENV
          DEFAULT_CONSTRAINTS_BRANCH=$(grep "export DEFAULT_CONSTRAINTS_BRANCH" \
            scripts/ci/libraries/_initialization.sh | \
            awk 'BEGIN{FS="="} {print $3}' | sed s'/["}]//g')
          echo "DEFAULT_CONSTRAINTS_BRANCH=${DEFAULT_CONSTRAINTS_BRANCH}" >> $GITHUB_ENV
          if [[ ${DEFAULT_BRANCH} != "v1-10-test" && \
            ( ${PYTHON_MAJOR_MINOR_VERSION} == "2.7" || ${PYTHON_MAJOR_MINOR_VERSION} == "3.5" ) \
          ]]; then
              echo "::set-output name=proceed::false"
          else
              echo "::set-output name=proceed::true"
          fi
      - name: >
          Checkout "${{ needs.cancel-workflow-runs.outputs.targetBranch }}" branch to 'main-airflow' folder
          to use ci/scripts from there.
        uses: actions/checkout@v2
        with:
          path: "main-airflow"
          ref: "${{ needs.cancel-workflow-runs.outputs.targetBranch }}"
          persist-credentials: false
          submodules: recursive
        if: steps.defaults.outputs.proceed == 'true'
      - name: Initiate GitHub Checks for Building image
        # Use the submodule from main, not the PR branch
        uses: ./main-airflow/.github/actions/checks-action
        id: build-image-check
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          name: "Status of image build CI: ${{ matrix.python-version }}"
          status: "in_progress"
          sha: ${{ needs.cancel-workflow-runs.outputs.sourceHeadSha }}
          details_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          output: >
            {"summary":
            "Building the image: CI: ${{ matrix.python-version }}. See the
            [Image Build](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            for details" }
        if: steps.defaults.outputs.proceed == 'true'
      - name: "Setup python"
        uses: actions/setup-python@v2
        with:
          python-version: ${{ needs.build-info.outputs.defaultPythonVersion }}
        if: steps.defaults.outputs.proceed == 'true'
      - name: >
          Override "scripts/ci" with the "${{ needs.cancel-workflow-runs.outputs.targetBranch }}" branch
          so that the PR does not override it
        # We should not override those scripts which become part of the image as they will not be
        # changed in the image built - we should only override those that are executed to build
        # the image.
        run: |
          rm -rf "scripts/ci"
          mv "main-airflow/scripts/ci" "scripts"
        if: steps.defaults.outputs.proceed == 'true'
      - name: "Free space"
        run: ./scripts/ci/tools/ci_free_space_on_ci.sh
        if: steps.defaults.outputs.proceed == 'true'
      - name: "Build CI images ${{ matrix.python-version }}:${{ github.event.workflow_run.id }}"
        run: ./scripts/ci/images/ci_prepare_ci_image_on_ci.sh
        if: steps.defaults.outputs.proceed == 'true'
      - name: "Push CI images ${{ matrix.python-version }}:${{ github.event.workflow_run.id }}"
        run: ./scripts/ci/images/ci_push_ci_images.sh
        if: steps.defaults.outputs.proceed == 'true'
      - name: Update GitHub Checks for Building image with status
        uses: ./main-airflow/.github/actions/checks-action
        if: always() && steps.defaults.outputs.proceed == 'true'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          check_id: ${{ steps.build-image-check.outputs.check_id }}
          status: "completed"
          sha: ${{ needs.cancel-workflow-runs.outputs.sourceHeadSha }}
          conclusion: ${{ job.status }}
          details_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          output: >
            {"summary":
            "Building the image: CI: ${{ matrix.python-version }}. See the
            [Image Build](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            for details" }

  pytest:
    needs: [build-info, cancel-workflow-runs, build-ci-images]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [2.7, 3.5, 3.6, 3.7, 3.8]
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    - name: Test with pytest
      run: |
        pytest ./airflow/dags/test.py

  dagValidation:
    needs: pytest
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: 'Validate DAGs'
        uses: ./
        with:
          requirementsFile: airflow/requirements.txt
          dagPaths: airflow/dags

  createPullRequest:
    needs: dagValidation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Make changes to pull request
        run: date +%s > report.txt

      - name: Create Pull Request
        id: cpr
        uses: peter-evans/create-pull-request@v3
        with:
          token: ${{ secrets.PAT }}
          commit-message: Update report
          committer: GitHub <noreply@github.com>
          author: ${{ github.actor }} <${{ github.actor }}@pedidosya.com>
          signoff: false
          branch: example-patches
          delete-branch: true
          title: '[DTDO] Update report'
          body: |
            Update report
            - Updated with *today's* date
            - Auto-generated by [create-pull-request][1]

          labels: |
            report
            automated pr
          assignees: diego-garcia
          reviewers: estefano-ramirez
          team-reviewers: |
            dataops
          milestone: 1
          draft: false

      - name: Check outputs
        run: |
          echo "Pull Request Number - ${{ steps.cpr.outputs.pull-request-number }}"
          echo "Pull Request URL - ${{ steps.cpr.outputs.pull-request-url }}"

  # create_PR:
  #   needs: styles
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@master
  #     - name: upload_files to gcs
  #       uses: ./.github/actions/upload_file
  # upload_file:
  #   needs: styles
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@master
  #     - name: upload_files to gcs
  #       uses: ./.github/actions/upload_file
  # setup-build-publish-deploy:
  #   name: Setup, Build, Publish, and Deploy
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Checkout
  #     uses: actions/checkout@master
  
      # Upload file to gcs


      # Example of using the output
      # - name: uploaded-files
      #   if: success()
      #   uses: ./
      #   env:
      #     file: ${{steps.upload-file.outputs.uploaded}}

    # # Configure Docker with Credentials
    # - name: Configure Docker
    #   run: |
    #     gcloud auth configure-docker
      
    # # Build the Docker image
    # - name: Build & Publish
    #   run: |
    #     gcloud config set project ${{ secrets.GCP_PROJECT }}
    #     gcloud builds submit --tag gcr.io/${{ secrets.GCP_PROJECT }}/${{ secrets.GCP_APPLICATION }}
    #     gcloud config set run/region us-central1
      
    # # Deploy the Docker image to the GKE cluster
    # - name: Deploy
    #   run: |
    #     gcloud run deploy ${{ secrets.GCP_APPLICATION }} --image gcr.io/${{ secrets.GCP_PROJECT }}/${{ secrets.GCP_APPLICATION }} \
    #     --platform managed \
    #     --allow-unauthenticated \
    #     --memory 512M

# Using databases and service containers
# If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.

# jobs:
#   container-job:
#     runs-on: ubuntu-latest
#     container: node:10.18-jessie
#     services:
#       postgres:
#         image: postgres
#     steps:
#       - name: Check out repository code
#         uses: actions/checkout@v2
#       - name: Install dependencies
#         run: npm ci
#       - name: Connect to PostgreSQL
#         run: node client.js
#         env:
#           POSTGRES_HOST: postgres
#           POSTGRES_PORT: 5432
