# name: Github Actions test

# on:
#   pull_request:
#   push:
#     branches:
#       - airflow

# jobs:
#   test:
#     name: Running Units Tests
#     runs-on: ubuntu-latest

# name: Testing Airflow workflow
# on:
#   push:
#     branches:
#       - airflow
# jobs:
#   checkout:
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout
#         uses: actions/checkout@master
#   python_lint:
#     needs: checkout
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@master
#       - uses: actions/setup-python@v2
#         with:
#           python-version: '3.8'
#       - name: Test
#         uses: onichandame/python-test-action@master
#         with:
#           deps_list: 'requirements'
#   styles:
#     needs: python_lint
#     runs-on: ubuntu-18.04
#     name: Linting
#     steps:
#       - uses: actions/checkout@master
#       - uses: actions/setup-python@v1
#       - uses: whynothugo/python-linting@master
  
# name: Testing Airflow workflow
# on:
#   push:
#     branches:
#       - airflow

jobs:
  build:

    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [2.7, 3.5, 3.6, 3.7, 3.8]

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    - name: Test with pytest
      run: |
        pytest ./airflow/dags/test.py
  
  # create_PR:
  #   needs: styles
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@master
  #     - name: upload_files to gcs
  #       uses: ./.github/actions/upload_file
  # upload_file:
  #   needs: styles
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@master
  #     - name: upload_files to gcs
  #       uses: ./.github/actions/upload_file
  # setup-build-publish-deploy:
  #   name: Setup, Build, Publish, and Deploy
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Checkout
  #     uses: actions/checkout@master
  
      # Upload file to gcs


      # Example of using the output
      # - name: uploaded-files
      #   if: success()
      #   uses: ./
      #   env:
      #     file: ${{steps.upload-file.outputs.uploaded}}

    # # Configure Docker with Credentials
    # - name: Configure Docker
    #   run: |
    #     gcloud auth configure-docker
      
    # # Build the Docker image
    # - name: Build & Publish
    #   run: |
    #     gcloud config set project ${{ secrets.GCP_PROJECT }}
    #     gcloud builds submit --tag gcr.io/${{ secrets.GCP_PROJECT }}/${{ secrets.GCP_APPLICATION }}
    #     gcloud config set run/region us-central1
      
    # # Deploy the Docker image to the GKE cluster
    # - name: Deploy
    #   run: |
    #     gcloud run deploy ${{ secrets.GCP_APPLICATION }} --image gcr.io/${{ secrets.GCP_PROJECT }}/${{ secrets.GCP_APPLICATION }} \
    #     --platform managed \
    #     --allow-unauthenticated \
    #     --memory 512M

# Using databases and service containers
# If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.

# jobs:
#   container-job:
#     runs-on: ubuntu-latest
#     container: node:10.18-jessie
#     services:
#       postgres:
#         image: postgres
#     steps:
#       - name: Check out repository code
#         uses: actions/checkout@v2
#       - name: Install dependencies
#         run: npm ci
#       - name: Connect to PostgreSQL
#         run: node client.js
#         env:
#           POSTGRES_HOST: postgres
#           POSTGRES_PORT: 5432